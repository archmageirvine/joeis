package irvine.math.api;

import java.util.Random;

import irvine.math.graph.Graph;
import irvine.math.polynomial.CycleIndex;
import irvine.math.z.Z;
import irvine.util.Pair;

/**
 * Definition of a group and associated operations.
 * @author Sean A. Irvine
 * @param <E> element type
 */
public interface Group<E> extends Set<E> {

  /**
   * Return the zero of the group.
   * @return the zero
   */
  E zero();

  /**
   * Add two group elements.
   * @param a first element
   * @param b second element
   * @return <code>a+b</code>
   * @exception IllegalArgumentException if supplied elements are not in the
   * group (or in some cases, if they cannot be coerced into members of the
   * group). This may be thrown for null arguments.
   * @exception NullPointerException may be thrown for null arguments.
   */
  E add(E a, E b);

  /**
   * Return a negative of an element.  That is, return an element
   * <code>a'</code> such that <code>a+a'=0</code>.
   * @param a element to get negative of
   * @return negative
   * @exception NullPointerException if argument is null.
   */
  E negate(E a);

  /**
   * Convenience method for <code>add(a, negate(b))</code>
   * @param a first element
   * @param b second element
   * @return <code>a-b</code>
   * @exception IllegalArgumentException if supplied elements are not in the
   * group, (or in some cases) if they cannot be coerced into members of the
   * group. This may be thrown for null arguments.
   * @exception NullPointerException may be thrown for null arguments.
   */
  E subtract(final E a, final E b);

  /**
   * If the condition is true return <code>a+b</code> otherwise return
   * <code>a-b</code>. Provided for convenience.
   * @param condition true for addition, false for subtraction
   * @param a first number
   * @param b number to add or subtract
   * @return signed addition
   */
  E signedAdd(final boolean condition, final E a, final E b);

  /**
   * Test if the group is Abelian; that is, test if the group operation is
   * commutative.
   * @return true iff the group is commutative
   */
  boolean isAbelian();

  /**
   * Return the order of the specified element in the group.  If the order is
   * infinite, then null is returned.
   * @param element element to get order of
   * @return order of the element or null if the order is infinite
   */
  Z order(final E element);
  
  /**
   * Return true iff this group is cyclic.
   * @return true iff the group is cyclic
   */
  boolean isCyclic();

  /**
   * Return true iff this group is simple.  That is, return true iff the group
   * has no non-trivial normal subgroup.
   * @return true iff the group is simple
   */
  boolean isSimple();

  /**
   * Return the cycle index object for this group.
   * @return cycle index
   * @exception UnsupportedOperationException if the operation cannot be performed.
   */
  CycleIndex cycleIndex();

  /**
   * Return the group as an operation.
   * @return the group as an operation
   */
  Operation<E> operation();

  /**
   * Test if the supplied set of elements (potentially already a group,
   * ring, or other structure) is a subgroup of this group.
   * @param elements set of elements
   * @return true if it forms a subgroup
   * @throws UnsupportedOperationException if the operation cannot be performed.
   */
  boolean isSubgroup(final Set<E> elements);

  /**
   * Test if the supplied set of elements (potentially already a group,
   * ring, or other structure) is a normal subgroup of this group.
   * @param elements set of elements
   * @return true if it forms a normal subgroup
   * @throws UnsupportedOperationException if the operation cannot be performed.
   */
  boolean isNormalSubgroup(final Set<E> elements);

  /**
   * Test if the supplied set of elements (potentially already a group,
   * ring, or other structure) is a Sylow subgroup of this group.
   * @param elements set of elements
   * @return true if it forms a Sylow subgroup
   * @throws UnsupportedOperationException if the operation cannot be performed.
   */
  boolean isSylowSubgroup(final Set<E> elements);

  /**
   * Return the subgroup generated by the supplied element.
   * @param element element to generate subgroup from
   * @return the subgroup generated by <code>element</code>
   */
  Group<E> subgroup(final E element);

  /**
   * Return the subgroup generated by the supplied elements.
   * @param elements elements to generate subgroup from
   * @return the subgroup generated by <code>elements</code>
   */
  Group<E> generateSubgroup(final Set<E> elements);

  /**
   * Return the centralizer of the group.  That is the subgroup of this group
   * where <code>add(a, element) == add(element, a)</code>.
   * @param element base element
   * @return the centralizer
   */
  Group<E> centralizer(final E element);

  /**
   * Return the centre of the group.  That is the subgroup of this group
   * where <code>add(a, x) == add(x, a)</code> for all <code>x</code> in
   * the base set.
   * @param base base set
   * @return the centre
   */
  Group<E> centre(final Set<E> base);

  /**
   * Return the right coset induced by a set and element in this group.
   * @param set a subset or subgroup of this group
   * @param element the element of interest
   * @return the right coset formed by the set and element
   */
  Set<E> rightCoset(final Set<E> set, final E element);

  /**
   * Return the left coset induced by a set and element in this group.
   * @param set a subset or subgroup of this group
   * @param element the element of interest
   * @return the left coset formed by the set and element
   */
  Set<E> leftCoset(final E element, final Set<E> set);
  
  /**
   * Return the index of the specified subgroup in this group.  A return
   * of null indicates infinite index.
   * @param subgroup subgroup
   * @return index of subgroup in this group
   * @throws IllegalArgumentException if <code>subgroup</code> is not a subgroup.
   * @throws UnsupportedOperationException if the operation cannot be performed.
   */
  Z index(final Group<E> subgroup);

  /**
   * Return the exponent of the group; that is, the least positive integer
   * such that any element of the group to that power is the identity.
   * @return exponent or null if exponent is infinite
   * @throws UnsupportedOperationException if the operation cannot be performed.
   */
  Z exponent();

  /**
   * Test if two groups are isomorphic.
   * @param group other group
   * @return true iff this group is isomorphic to the given group
   * @throws UnsupportedOperationException if the isomorphism status cannot
   * be determined.
   */
  boolean isIsomorphic(final Group<?> group);

  /**
   * Construct the quotient group defined by this group and the given
   * normal subgroup.
   * @param normalSubgroup normal subgroup
   * @return quotient group
   */
  QuotientGroup<E> quotientGroup(final Group<E> normalSubgroup);

  /**
   * Convenience method to coerce a small integer into the type of this ring.
   * This is often useful and can avoid cumbersome construction of group
   * elements in some cases.  However, this operation need not be supported
   * by every group.
   * @param n number of coerce
   * @return coerced values
   */
  E coerce(final long n);

  /**
   * Convenience method to coerce an integer into the type of this ring.
   * This is often useful and can avoid cumbersome construction of group
   * elements in some cases.  However, this operation need not be supported
   * by every group.
   * @param n number of coerce
   * @return coerced values
   */
  E coerce(final Z n);

  /**
   * Return a random element of the group.
   * @param random underlying source of randomness
   * @return a randomly selected element
   * @throws UnsupportedOperationException if the operation cannot be performed.
   */
  E random(final Random random);

  /**
   * Convenience method to add an element to itself a given number of times.
   * @param a element of rings
   * @param n multiplicity (can be negative)
   * @return <code>a+a+....+a</code> (<code>n</code> times).
   */
  E groupMultiply(final E a, final Z n);

  /**
   * Convenience method to add an element to itself a given number of times.
   * @param a element of rings
   * @param n multiplicity (can be negative)
   * @return <code>a+a+....+a</code> (<code>n</code> times).
   */
  E groupMultiply(final E a, final long n);

  /**
   * Return the order of the automorphism group of this group.
   * @return automorphism order
   */
  Z autOrder();

  /**
   * Return the center of the group; that is, the set of commutative elements in the group.
   * @return center of the group
   */
  Set<E> center();

  /**
   * Return the derived subgroup (also called commutator subgroup) of this group.
   * @return derived subgroup.
   */
  Group<Pair<E, E>> derivedSubgroup();

  /**
   * Return the number of conjugacy classes in the group.
   * @return number of conjugacy classes
   */
  Z numberConjugacyClasses();

  /**
   * Construct the Cayley graph of the group.
   * @return Cayley graph
   */
  Graph cayleyGraph();
}
