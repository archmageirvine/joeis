package irvine.math.api;

import irvine.math.z.Z;

/**
 * Definition of a ring and associated operations.
 *
 * @author Sean A. Irvine
 * @param <E> element type
 */
public interface Ring<E> extends Group<E> {

  /**
   * Return the multiplicative identity of the ring.
   * @return the one
   */
  E one();

  /**
   * Multiply two ring elements.
   * @param a first element
   * @param b second element
   * @return <code>a&times;b</code>
   * @exception IllegalArgumentException if supplied elements are not in the
   * group (or in some cases, if they cannot be coerced into members of the
   * group. This may be thrown for null arguments.
   * @exception NullPointerException may be thrown for null arguments.
   */
  E multiply(E a, E b);

  /**
   * Convenience method to compute powers.  Supports non-negative powers.
   * @param a base
   * @param n power
   * @return <code>a^n</code>
   */
  E pow(E a, long n);

  /**
   * Return the multiplicative order of an element in the ring or null if it
   * is not defined or infinite.
   * @param element the element
   * @return order of the element
   */
  Z ord(E element);

  /**
   * Test if the ring is commutative; that is, test if the multiplicative
   * operation of the ring is commutative. See also <code>isAbelian</code>.
   * @return true iff the ring is commutative
   */
  boolean isCommutative();

  /**
   * Test if the ring is an integral domain.  That is, the ring is
   * commutative and contains no zero divisors.
   * @return true iff the ring is an integral domain
   */
  boolean isIntegralDomain();

  /**
   * Test if the specified element is a zero divisor in the ring.  If the
   * element is a zero divisor then returns an element <code>a</code>
   * such that <code>multiply(element, a)</code> is zero. Otherwise null
   * is returned.
   * @param element element to test
   * @return null if not a zero divisor, otherwise an element that when
   * multiplied by the given element is zero
   * @throws irvine.math.set.EffortException if the determination could not be made
   * within the specified effort.
   * @throws ArithmeticException if <code>element</code> is the zero.
   */
  E isZeroDivisor(E element);

  /**
   * The characteristic of the ring. That is, the least integer <code>n</code>
   * such that <code>n * one() == zero()</code>; or 0 if no such integer
   * <code>n</code> exists.
   * @return characteristic
   */
  Z characteristic();

  /**
   * Test if the supplied set of elements (potentially already a group,
   * ring, or other structure) is a subring of this ring.
   * @param elements set of elements
   * @return true if it forms a subring
   * @throws UnsupportedOperationException if the operation cannot be performed.
   */
  boolean isSubring(final Set<E> elements);

  /**
   * Test if the supplied set of elements (potentially already a group,
   * ring, or other structure) is an ideal of this ring.
   * @param elements set of elements
   * @return true if it forms an ideal
   * @throws UnsupportedOperationException if the operation cannot be performed.
   */
  boolean isIdeal(final Set<E> elements);

  /**
   * Construct the ideal generated by the given element
   * @param element element to generate ideal
   * @return the ideal
   * @throws UnsupportedOperationException if the operation cannot be performed.
   */
  Ring<E> ideal(final E element);

  /**
   * Construct the quotient ring defined by this ring and the given ideal.
   * @param ideal ideal to make quotient from
   * @return quotient ring
   */
  Ring<Set<E>> quotientRing(final Ring<E> ideal);

  /**
   * Return the multiplication of the ring as an operation.
   * @return the multiplication of the ring as an operation
   */
  Operation<E> multiplicativeOperation();

  /**
   * Return the conjugate of an element.
   * @param element element to conjugate
   * @return the conjugate
   */
  E conjugate(E element);

}
