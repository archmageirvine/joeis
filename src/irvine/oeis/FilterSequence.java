package irvine.oeis;

import java.util.function.Function;

import irvine.math.z.Z;

/**
 * A sequence generated by selecting particular terms from another sequence.
 * @author Sean A. Irvine
 */
public class FilterSequence implements SequenceWithOffset {

  /** Odd terms. */
  public static final Function<Z, Boolean> ODD = Z::isOdd;
  /** Even terms. */
  public static final Function<Z, Boolean> EVEN = Z::isEven;
  /** Prime terms. */
  public static final Function<Z, Boolean> PRIME = Z::isProbablePrime;
  /** Nonzero terms. */
  public static final Function<Z, Boolean> NONZERO = k -> !k.isZero();

  private final Sequence mSeq;
  private final Function<Z, Boolean> mPredicate;
  private final int mOffset;

  /**
   * Filter.
   * @param offset offset of filtered sequence
   * @param seq underlying sequence
   * @param predicate predicate used for filtering
   */
  public FilterSequence(final int offset, final Sequence seq, final Function<Z, Boolean> predicate) {
    mOffset = offset;
    mSeq = seq;
    mPredicate = predicate;
  }

  /**
   * Filter with inferred offset.  If <code>seq</code> has an offset, that will be used,
   * otherwise the offset will be 1.
   * @param seq first sequence
   * @param predicate combination operation
   */
  public FilterSequence(final Sequence seq, final Function<Z, Boolean> predicate) {
    this(seq instanceof SequenceWithOffset ? ((SequenceWithOffset) seq).getOffset() : 1, seq, predicate);
  }

  @Override
  public int getOffset() {
    return mOffset;
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq.next();
      if (t == null || mPredicate.apply(t)) {
        return t;
      }
    }
  }
}
