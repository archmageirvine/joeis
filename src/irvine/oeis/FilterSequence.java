package irvine.oeis;

import java.util.function.BiPredicate;
import java.util.function.Predicate;

import irvine.math.z.Z;
import irvine.util.string.StringUtils;

/**
 * A sequence generated by selecting particular terms from another sequence.
 * @author Sean A. Irvine
 */
public class FilterSequence extends AbstractSequence {

  /** Prime terms. */
  public static final Predicate<Z> PROBABLE_PRIME = Z::isProbablePrime;
  /** Non-prime terms. */
  public static final Predicate<Z> NONPRIME = k -> !k.isProbablePrime();
  /** Nonzero terms. */
  public static final Predicate<Z> NONZERO = k -> !k.isZero();
  /** Palindromic terms. */
  public static final Predicate<Z> PALINDROME = k -> StringUtils.isPalindrome(k.toString());

  protected final Sequence mSeq;
  protected final Predicate<Z> mPredicate;
  protected final BiPredicate<Long, Z> mBiPredicate;
  private long mN = 0;

  /**
   * Filter with both the index and sequence value.
   * @param offset offset of filtered sequence
   * @param seq underlying sequence
   * @param predicate predicate used for filtering
   */
  public FilterSequence(final int offset, final Sequence seq, final BiPredicate<Long, Z> predicate) {
    super(offset);
    mSeq = seq;
    mPredicate = null;
    mBiPredicate = predicate;
    mN = seq.getOffset() - 1;
  }

  /**
   * Filter with just the sequence value.
   * @param offset offset of filtered sequence
   * @param seq underlying sequence
   * @param predicate predicate used for filtering
   */
  public FilterSequence(final int offset, final Sequence seq, final Predicate<Z> predicate) {
    super(offset);
    mSeq = seq;
    mPredicate = predicate;
    mBiPredicate = null;
  }

  /**
   * Filter with inferred offset.  If <code>seq</code> has an offset, that will be used,
   * otherwise the offset will be 1.
   * @param seq first sequence
   * @param predicate combination operation
   */
  public FilterSequence(final Sequence seq, final Predicate<Z> predicate) {
    this(seq.getOffset(), seq, predicate);
  }

  @Override
  public Z next() {
    if (mPredicate != null) {
      while (true) {
        final Z t = mSeq.next();
        if (t == null || mPredicate.test(t)) {
          return t;
        }
      }
    } else {
      assert mBiPredicate != null;
      while (true) {
        ++mN;
        final Z t = mSeq.next();
        if (t == null || mBiPredicate.test(mN, t)) {
          return t;
        }
      }
    }
  }
}
