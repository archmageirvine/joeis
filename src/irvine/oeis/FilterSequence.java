package irvine.oeis;

import java.util.function.Predicate;

import irvine.math.z.Z;
import irvine.util.string.StringUtils;

/**
 * A sequence generated by selecting particular terms from another sequence.
 * @author Sean A. Irvine
 */
public class FilterSequence extends AbstractSequence {

  /** Odd terms. */
  public static final Predicate<Z> ODD = Z::isOdd;
  /** Even terms. */
  public static final Predicate<Z> EVEN = Z::isEven;
  /** Prime terms. */
  public static final Predicate<Z> PRIME = Z::isProbablePrime;
  /** Zero terms. */
  public static final Predicate<Z> ZERO = k -> k.isZero();
  /** Nonzero terms. */
  public static final Predicate<Z> NONZERO = k -> !k.isZero();
  /** Palindromic terms. */
  public static final Predicate<Z> PALINDROME = k -> StringUtils.isPalindrome(k.toString());

  protected final Sequence mSeq;
  protected final Predicate<Z> mPredicate;

  /**
   * Filter.
   * @param offset offset of filtered sequence
   * @param seq underlying sequence
   * @param predicate predicate used for filtering
   */
  public FilterSequence(final int offset, final Sequence seq, final Predicate<Z> predicate) {
    super(offset);
    mSeq = seq;
    mPredicate = predicate;
  }

  /**
   * Filter with inferred offset.  If <code>seq</code> has an offset, that will be used,
   * otherwise the offset will be 1.
   * @param seq first sequence
   * @param predicate combination operation
   */
  public FilterSequence(final Sequence seq, final Predicate<Z> predicate) {
    this(seq instanceof SequenceWithOffset ? ((SequenceWithOffset) seq).getOffset() : 1, seq, predicate);
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq.next();
      if (t == null || mPredicate.test(t)) {
        return t;
      }
    }
  }
}
