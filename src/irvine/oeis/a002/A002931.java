package irvine.oeis.a002;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.util.Point;

/**
 * A002931 Number of self-avoiding polygons of length 2n on square lattice (not allowing rotations).
 * @author Sean A. Irvine
 */
public class A002931 implements Sequence {

  // Backtracking search -- only good for a few terms of this sequence!

  // Polygons unique up to translation.  Handled by a canonicalization method:
  // (a) translated polygon so that all points are non-negative
  // (b) select "start point" to be a point (min{x},0)
  // (c) select winding direction to that the first step from the "start point" increases x

  /**
   * Representation of a polygon on the square lattice.
   */
  public static final class Polygon extends LinkedHashSet<Point> {
    private final Point mHead;

    /**
     * Construct a new polygon.
     * @param parent parent polygon
     * @param head point to add
     */
    public Polygon(final Polygon parent, final Point head) {
      if (parent != null) {
        addAll(parent);
      }
      if (head != null) {
        add(head);
      }
      mHead = head;
    }

    private Point head() {
      return mHead;
    }

    /**
     * Translate to canonical position.
     * @return canonical form of the polygon
     */
    public Polygon canonicalize() {
      int minX = Integer.MAX_VALUE;
      int minY = Integer.MAX_VALUE;
      for (final Point cell : this) {
        minX = Math.min(minX, cell.left());
        minY = Math.min(minY, cell.right());
      }
      final ArrayList<Point> translatedPoints = new ArrayList<>();
      for (final Point cell : this) {
        translatedPoints.add(new Point(cell.left() - minX, cell.right() - minY));
      }
      // Find least y = 0 point to be canonical
      int best = -1;
      final int size = translatedPoints.size();
      for (int k = 0; k < size; ++k) {
        final Point pt = translatedPoints.get(k);
        if (pt.right() == 0 && (best == -1 || pt.left() < translatedPoints.get(best).left())) {
          best = k;
        }
      }
      assert best >= 0;
      // Now determine winding direction so that x increases on the first step
      final int bestx = translatedPoints.get(best).left();
      final int dir = translatedPoints.get((best + 1) % size).left() > bestx ? 1 : -1;
      final Polygon translate = new Polygon(null, null); // critical that head is null for comparisons to work
      for (int k = 0; k < size; ++k) {
        final Point e = translatedPoints.get((size + dir * k + best) % size);
        translate.add(e);
      }
      return translate;
    }

    @Override
    public boolean equals(final Object o) {
      if (!super.equals(o)) {
        return false; // has different points
      }
      if (!(o instanceof Polygon)) {
        return false;
      }
      // Check ordering of points is the same
      final Iterator<Point> a = this.iterator();
      final Iterator<Point> b = ((Polygon) o).iterator();
      while (a.hasNext()) {
        assert b.hasNext();
        final Point ap = a.next();
        final Point bp = b.next();
        if (!ap.equals(bp)) {
          return false;
        }
      }
      return true;
    }

    @Override
    public int hashCode() {
      return super.hashCode();
    }
  }

  private static final Polygon FIRST_EDGE = new Polygon(null, new Point(1, 0));

  private static final int[] DELTA_X = {1, -1, 0, 0};
  private static final int[] DELTA_Y = {0, 0, 1, -1};

  protected int mN = 0;
  protected final HashSet<Polygon> mPolygons = new HashSet<>();

  private void search(final int distanceRemaining, final Polygon pathSoFar) {
    assert distanceRemaining >= 0;
    final Point head = pathSoFar.head();
    if (distanceRemaining == 0) {
      final int x = head.left();
      final int y = head.right();
      if (x == 0 && y == 0) {
        mPolygons.add(pathSoFar.canonicalize());
      }
      return;
    }
    // Four candidate steps at each point.  One is guaranteed to be already present in the polygon,
    // but depending on the structure more than one might already be present.  Also, the step
    // might take us so far away from the origin that we can never get back
    final int x = head.left();
    final int y = head.right();
    final int remaining = distanceRemaining - 1;
    for (int k = 0; k < DELTA_X.length; ++k) {
      final int nx = x + DELTA_X[k];
      final int ny = y + DELTA_Y[k];
      if (ny < 0) {
        continue; // this one can always be generated by a different path
      }
      if (ny == 0 && nx < 0) {
        continue; // this one can always be generated by a different path
      }
      if (nx == 0 && ny == 0 && remaining != 0) {
        continue; // can't return to origin yet
      }
      if (Math.abs(nx) + Math.abs(ny) > remaining) {
        continue; // current head is too far from the origin to ever return
      }
      final Point newHead = new Point(nx, ny);
      if (pathSoFar.contains(newHead)) {
        continue; // intersects an existing point
      }
      search(remaining, new Polygon(pathSoFar, newHead));
    }
  }

  protected Z postFilter() {
    return Z.valueOf(mPolygons.size());
  }

  @Override
  public Z next() {
    mN += 2;
    if (mN == 2) {
      return Z.ZERO; // Otherwise the search will find (0,0)->(1,0)->(0,0)
    }
    mPolygons.clear();
    // Start with the edge (0,0) -> (1,0)
    search(mN - 1, FIRST_EDGE);
    return postFilter();
  }
}

