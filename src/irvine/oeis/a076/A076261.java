package irvine.oeis.a076;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import irvine.math.z.Z;
import irvine.oeis.Sequence2;

/**
 * A076261 Triangle T(n,k) (n &gt;= 2, 1 &lt;= k &lt;= n-1) read by rows, where T(n,k) is the number of words of length n in the free group on two generators that require exactly k multiplications for their formation.
 * @author Sean A. Irvine
 */
public class A076261 extends Sequence2 {

  // Mostly brute force, backtracking search keeping the best solution for each word.

  // Each Chain provides a list of elements generated by one multiplication per step
  // Starting from the head of a Chain elements never increase in length; that is,
  // mElement.length() >= mParent.mElement.length(), and more precisely the Chain
  // is increasing in length and lexicographic ordering of words.

  private static final class Chain {
    private final String mElement;
    private final Chain mParent;

    private Chain(final String element, final Chain parent) {
      mElement = element;
      mParent = parent;
    }

    private boolean contains(final String s) {
      if (s.equals(mElement)) {
        return true;
      }
      if (mParent == null || s.length() > mElement.length()) {
        return false;
      }
      if (s.length() == mElement.length() && s.compareTo(mElement) > 0) {
        return false;
      }
      return mParent.contains(s);
    }
  }

  private int mN = 1;
  private int mM = 0;
  private int mZeroAdjust = 0;
  private final String[] mGenerators;
  private final Map<String, Integer> mBestSolutions = new HashMap<>();

  protected A076261(final String... generators) {
    mGenerators = generators;
  }

  /** Construct the sequence. */
  public A076261() {
    this("a", "b");
  }

  private void search(final Chain set, final int depth) {
    if (depth == mN - mZeroAdjust) {
      return;
    }
    final Set<String> localSeen = new HashSet<>();
    for (Chain s = set; s != null; s = s.mParent) {
      for (Chain t = set; t != null; t = t.mParent) {
        final int len = s.mElement.length() + t.mElement.length();
        if (len > mN) {
          continue;
        }
        final String u = s.mElement + t.mElement;
        if (len == mN) {
          mBestSolutions.merge(u, depth, Integer::min);
        } else {
          if (len > set.mElement.length() || (len == set.mElement.length() && u.compareTo(set.mElement) > 0)) {
            if (localSeen.add(u) && !set.contains(u)) {
              search(new Chain(u, set), depth + 1);
            }
          }
        }
      }
    }
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 1;
      mBestSolutions.clear();
      Chain c = null;
      for (final String g : mGenerators) {
        c = new Chain(g, c);
      }
      search(c, 1);
    }
    int cnt = 0;
    for (final int v : mBestSolutions.values()) {
      if (v == mM) {
        ++cnt;
      }
    }
    if (cnt != 0) {
      mZeroAdjust = mN - 1 - mM;
    }
    return Z.valueOf(cnt);
  }
}
