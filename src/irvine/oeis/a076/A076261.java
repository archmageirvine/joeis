package irvine.oeis.a076;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import irvine.math.z.Z;
import irvine.oeis.Sequence2;

/**
 * A076261 Triangle T(n,k) (n &gt;= 2, 1 &lt;= k &lt;= n-1) read by rows, where T(n,k) is the number of words of length n in the free group on two generators that require exactly k multiplications for their formation.
 * @author Sean A. Irvine
 */
public class A076261 extends Sequence2 {

  // Mostly brute force

  // This structure is used instead of sets to avoid excessive memory.
  // Each Chain provides a list of elements generated by one multiplication per step
  // Starting from the head of a Chain elements never increase in length; that is,
  // mElement.length() >= mParent.mElement.length()

  // todo this was worse than the sets I think chains repeating!

  private static final class Chain {
    private final String mElement;
    private final Chain mParent;

    private Chain(final String element, final Chain parent) {
      mElement = element;
      mParent = parent;
    }

    private boolean contains(final String s) {
      if (s.equals(mElement)) {
        return true;
      }
      if (mParent == null || s.length() > mElement.length()) {
        return false;
      }
      return mParent.contains(s);
    }

    @Override
    public boolean equals(final Object obj) {
      if (!(obj instanceof Chain)) {
        return false;
      }
      // WARNING: Assumes chains are the same length
      final Chain other = (Chain) obj;
      for (Chain c = this; c != null; c = c.mParent) {
        if (!other.contains(c.mElement)) {
          return false;
        }
      }
      return true;
    }

    @Override
    public int hashCode() {
      if (mParent == null) {
        return mElement.hashCode();
      } else {
        return mElement.hashCode() + mParent.hashCode();
      }
    }
  }

  private int mN = 1;
  private int mM = 0;
  private Collection<Chain> mSets = null;
  private final Set<String> mSeen = new HashSet<>();
  private final String[] mGenerators;

  protected A076261(final String... generators) {
    mGenerators = generators;
  }

  /** Construct the sequence. */
  public A076261() {
    this("a", "b");
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 1;
      mSeen.clear();
      mSets = new HashSet<>();
      Chain c = null;
      for (final String g : mGenerators) {
        c = new Chain(g, c);
      }
      mSets.add(c); // Start with a single chain containing elements needing no multiplication
    }
    // For each existing set, consider each possible multiplication of 2 elements within that set.
    // Retain if the multiplied word is not already in the set and not longer than mN
    // Keep track of the first time we see words of length mN
    int cnt = 0;
    // If we've already seen every word of length n, there is no point in searching further
    if (mSeen.size() < Z.valueOf(mGenerators.length).pow(mN).intValueExact()) {
      final Collection<Chain> next = new HashSet<>();
      for (final Chain set : mSets) {
        for (Chain s = set; s != null; s = s.mParent) {
          for (Chain t = set; t != null; t = t.mParent) {
            final String u = s.mElement + t.mElement;
            if (u.length() == mN) {
              if (mSeen.add(u)) {
                ++cnt;
              }
            } else if (u.length() >= s.mElement.length() && u.length() < mN && !set.contains(u)) {
              next.add(new Chain(u, set));
            }
          }
        }
      }
      mSets = next;
    }
    return Z.valueOf(cnt);
  }
}
