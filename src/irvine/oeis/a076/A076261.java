package irvine.oeis.a076;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import irvine.math.z.Z;
import irvine.oeis.Sequence2;

/**
 * A076261 Triangle T(n,k) (n &gt;= 2, 1 &lt;= k &lt;= n-1) read by rows, where T(n,k) is the number of words of length n in the free group on two generators that require exactly k multiplications for their formation.
 * @author Sean A. Irvine
 */
public class A076261 extends Sequence2 {

  // Mostly brute force, also memory intensive despite Chains below

  // This structure is used instead of sets to avoid excessive memory.
  // Each Chain provides a list of elements generated by one multiplication per step
  // Starting from the head of a Chain elements never increase in length; that is,
  // mElement.length() >= mParent.mElement.length()

  private static final class Chain {
    private final byte[] mElement;
    private final Chain mParent;

    private Chain(final byte[] element, final Chain parent) {
      mElement = element;
      mParent = parent;
    }

    private boolean contains(final byte[] s) {
      if (Arrays.equals(s, mElement)) {
        return true;
      }
      if (mParent == null || s.length > mElement.length) {
        return false;
      }
      if (s.length == mElement.length && Arrays.compare(s, mElement) > 0) {
        return false;
      }
      return mParent.contains(s);
    }
  }

  private int mN = 1;
  private int mM = 0;
  private Collection<Chain> mSets = null;
  private final Set<String> mSeen = new HashSet<>();
  private final String[] mGenerators;

  protected A076261(final String... generators) {
    mGenerators = generators;
  }

  /** Construct the sequence. */
  public A076261() {
    this("a", "b");
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 1;
      mSeen.clear();
      mSets = new HashSet<>();
      Chain c = null;
      for (final String g : mGenerators) {
        c = new Chain(g.getBytes(StandardCharsets.UTF_8), c);
      }
      mSets.add(c); // Start with a single chain containing elements needing no multiplication
    }
    // For each existing set, consider each possible multiplication of 2 elements within that set.
    // Retain if the multiplied word is not already in the set and not longer than mN
    // Keep track of the first time we see words of length mN
    int cnt = 0;
    // If we've already seen every word of length n, there is no point in searching further
    if (mSeen.size() < Z.valueOf(mGenerators.length).pow(mN).intValueExact()) {
      final Collection<Chain> next = new ArrayList<>();
      for (final Chain set : mSets) {
        final Set<String> localSeen = new HashSet<>();
        for (Chain s = set; s != null; s = s.mParent) {
          for (Chain t = set; t != null; t = t.mParent) {
            final int len = s.mElement.length + t.mElement.length;
            if (len > mN) {
              continue;
            }
            final byte[] u = Arrays.copyOf(s.mElement, len);
            System.arraycopy(t.mElement, 0, u, s.mElement.length, t.mElement.length);
            if (len == mN) {
              final String us = new String(u);
              if (mSeen.add(us)) {
                ++cnt;
              }
            } else if (len > set.mElement.length || (len == set.mElement.length && Arrays.compare(u, s.mElement) > 0)) {
              final String us = new String(u);
              if (localSeen.add(us) && !set.contains(u)) {
                next.add(new Chain(u, set));
              }
            }
          }
        }
      }
      mSets = next;
    }
    return Z.valueOf(cnt);
  }
}
