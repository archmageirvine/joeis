package irvine.oeis.a131;

import java.util.HashMap;
import java.util.Locale;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A131388 Sequence (a(n)) generated by Rule 1 (in Comments) with a(1) = 1 and d(1) = 0.
 * @author Georg Fischer
 */
public class A131388 extends AbstractSequence {

  private enum Variant {
    /** Type "ak". */
    AK,
    /** Type "dk". */
    DK
  }

  private final int mRule;
  private final int mSub;
  private final Variant mVariant;
  private int mK;
  private int mAk;
  private int mDk;
  private int mAk1;
  private int mDk1;
  private final HashMap<Integer, Integer> mAMap;
  private final HashMap<Integer, Integer> mDMap;

  /** Construct the sequence. */
  public A131388() {
    this(1, 1, "ak", 1, 0);
  }

  /**
   * Generate OEIS Sequence A131393 and its companions as defined by Clark Kimberling.
   * @param rule major rule number according to Clark Kimberling
   * @param sub minor rule number
   * @param op operation: ak or dk
   * @param a1 start value of ak
   * @param d1 start value of dk
   */
  public A131388(final int rule, final int sub, final String op, final int a1, final int d1) {
    super(1);
    mRule = rule;
    mSub = sub;
    mAMap = new HashMap<>(2048);
    mDMap = new HashMap<>(2048);
    mVariant = Variant.valueOf(op.toUpperCase(Locale.getDefault()));
    mK = 1;
    mAk = a1;
    mAk1 = mAk;
    mDk = d1;
    mDk1 = mDk;
    mAMap.put(mAk, mK);
    mDMap.put(mDk, mK); // dk is h
  }

  @Override
  public Z next() {
    // implemented variants are ak, dk only
    final Z result;
    switch (mVariant) {
      case AK:
        result = Z.valueOf(mAk);
        break;
      case DK:
        result = Z.valueOf(mDk);
        break;
      default:
        throw new RuntimeException();
    } // switch mVariant

    ++mK;
    boolean busy = true;
    if (mRule == 1 || mRule == 2) { // for A131388, A257705 et al.
      mDk = -1; // start downwards
      if (mRule == 2 && mDk1 < 0) { // for A131393 et al.
        mDk = mDk1 - 1;
      }
      while (busy && mDk > mSub - mAk1) { // downwards
        mAk = mAk1 + mDk;
        if (mAk > 0 && mAMap.get(mAk) == null && mDMap.get(mDk) == null) {
          busy = false;
          mAMap.put(mAk, mK);
          mDMap.put(mDk, mK);
        } else {
          --mDk;
        }
      } // while downwards
      if (busy) {
        mDk = 1; // start upwards
      }
      while (busy) { // upwards
        mAk = mAk1 + mDk;
        if (mAMap.get(mAk) == null && mDMap.get(mDk) == null) {
          busy = false;
          mAMap.put(mAk, mK);
          mDMap.put(mDk, mK);
        } else {
          ++mDk;
        }
      } // while upwards
    } else if (mRule == 3) { // for A257905, 908
      mDk = mSub - mAk1 + 1; // start upwards in negative
      while (busy && mDk < 0) {
        mAk = mAk1 + mDk;
        if (mAk > 0 && mAMap.get(mAk) == null && mDMap.get(mDk) == null) {
          busy = false;
          mAMap.put(mAk, mK);
          mDMap.put(mDk, mK);
        } else {
          ++mDk;
        }
      } // while negative
      if (busy) {
        mDk = 1; // start upwards
      }
      while (busy) { // upwards
        mAk = mAk1 + mDk;
        if (mAMap.get(mAk1 - mDk) == null && mDMap.get(mDk) == null) {
          busy = false;
          mAMap.put(mAk, mK);
          mDMap.put(mDk, mK);
        } else {
          ++mDk;
        }
      } // while upwards
    } else if (mRule == 4) { // "Algorithm" for A257883 et al.
      mDk = mSub - mAk + 1;
      while (busy) { // upwards
        mAk = mAk1 + mDk;
        if (mAk > 0 && mAMap.get(mAk) == null && mDMap.get(mDk) == null) {
          busy = false;
          mAMap.put(mAk, mK);
          mDMap.put(mDk, mK);
        } else {
          ++mDk;
        }
      } // while upwards
    }
    mAk1 = mAk;
    mDk1 = mDk;
    ++mK; // iterate
    return result;
  } // next
}
