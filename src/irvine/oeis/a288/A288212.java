package irvine.oeis.a288;

import java.util.HashMap;

import irvine.factor.factor.Jaguar;
import irvine.factor.factor.PrimeDivision;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.Sequence1;
import irvine.util.string.StringUtils;

/**
 * A288212 Start with 2n, and if 2n+1 is composite, multiply by the smallest factor of 2n+1; if that number plus 1 is composite, multiply by the smallest factor of that number plus 1; continue until you have a number where z+1 is prime; this is the final z+1, or 0 if sequence diverges.
 * @author Sean A. Irvine
 */
public class A288212 extends Sequence1 {

  private Z mN = Z.ZERO;
  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  private final PrimeDivision mPrimeDivision = new PrimeDivision(10000000);

  // Hard cases, but where the lpf is confidently known
  private final HashMap<Z, Z> mHardCases = new HashMap<>();
  {
    mHardCases.put(new Z("1658151461612523934210160786231756703739801964685320323733936052636851061474243883100399686061583204219852341749971939932416275560056149605385015871113416466747381335194676015641415828470961339307286193009169155965829268282261446065385232041870905269704417986426614690675720116641"), Z.valueOf(121229832887L));
    mHardCases.put(new Z("201017424592621072090585574452276395646818160109275658388329807511909889880431149802943417384152995038218692598164711414946027160264549348997496469348922208887419031710513504988315839001611299896460009519984004436452321276232044652949615355713727632673674256380095533239756746848651347939681"), Z.valueOf(104661860755129L));
    mHardCases.put(new Z("160516503488884764616113429287091789592143480510890143941310542569330341031249966082450270790606162791823047836167654444098692539876258381680441545819337732414848738689948571507427105818158098007019192804931653096394336054651832733836408717229930766490666898191884987670922241760753648025983579625692313926154498318351575537748611681"), Z.valueOf(219069757));
    mHardCases.put(new Z("64264677876042248626448192396771053310811385666593669490620778464651603859097602730164010508470497395575523214025589399308771766055719008587472176389282468509611181709578379853086972291641715509475457380029558107080478803086615266539757670828883786618548367150736010962004026309792545054256111668200630139863777200819810575587007179700062100860154721"), Z.valueOf(1500716683));
    mHardCases.put(new Z("4905191197710026567268586801022692924356001200274081591738338410402538551907329002295434949281119791629836236668590926180519108813917994314418533628564565675979618363153693198383286346306143120628883293710329322890158836214502352845428686852201317340358365473937706976031308896536024083019674404810171987514677022488751400381777991490676052639545340817006019827361"), Z.valueOf(15725736207497L));
    mHardCases.put(new Z("3787503206296424530879561244704230749457318326762252883320712429632336011938159038643369927085491615874654666213292153936171534193163311345191187001131779057665860665309068084321"), Z.valueOf(5091324265667L));
    mHardCases.put(new Z("6034631619301404255167594416050906887112294642791819675147977160616907354822712763825319633173783064178938669264912118495754000511286240982973005832373693459522030597794456625702930403418354042819387389318333044110889608944798758607872795129879393233072141193557230632820592012321"), Z.valueOf(2798846359711L));
    mHardCases.put(new Z("21887385061277337443870630166904026815828107436365886252294957448842327879000648968182615907650641862966629967108175543408352766451247611704902266391069632529038310549491319559792227448330630335131682320572656523711672197893356109612386222608831823108331"), Z.valueOf(348005418751L));
    mHardCases.put(new Z("7616928603614201612100530609503688873270393683228327330881140701750100973705262503573147324380555566135632820842745986499440782279995729337753162254953140995067668430097307573445051095711337225677284572697990755654772444014321932966422723695329622271749140086295831"), Z.valueOf(13749980077272689L));
    mHardCases.put(new Z("6714883156168090370946937399114215802383668332309458426041578695364753103862310275699363661847845255923643303535760422063014712180341513083891676070116035260441971313142474693548858296745001916943398574411974050303844806127674147252276681757549708020422084253628553512202493456039813221031947744004871"), Z.valueOf(57076499));
  }

  private Z lpf(final Z u) {
    try {
      final Z lpf = Jaguar.factor(u).leastPrimeFactor();
      if (mVerbose) {
        StringUtils.message(mN + " jaguar " + lpf + " is lpf of " + u);
      }
      return lpf;
    } catch (final UnsupportedOperationException e) {
      // We only require lpf, sometimes we can get it this way even if the entire factorization is unknown
      final FactorSequence fs = new FactorSequence(u);
      mPrimeDivision.factor(fs);
      final Z[] p = fs.toZArray();
      if (p.length > 0 && p[0].isProbablePrime()) {
        if (mVerbose) {
          StringUtils.message(mN + " trial " + p[0] + " is lpf of " + u);
        }
        return p[0];
      } else {
        final Z lpf = mHardCases.get(u);
        if (lpf != null) {
          if (mVerbose) {
            StringUtils.message(mN + " special " + lpf + " is lpf of " + u);
          }
          return lpf;
        }
        throw e;
      }
    }
  }

  @Override
  public Z next() {
    mN = mN.add(2);
    if (mVerbose) {
      StringUtils.message("Starting search for a(" + mN.divide2() + ")");
    }
    Z t = mN;
    Z u;
    while (!(u = t.add(1)).isProbablePrime()) {
      t = t.multiply(lpf(u));
    }
    return u;
  }

  /**
   * Run this sequence for a specific value.
   * @param args value to run
   */
  public static void main(final String... args) {
    final A288212 seq = new A288212();
    seq.mN = new Z(args[0]).multiply2().subtract(2);
    System.out.println(seq.next());
  }
}
